#!/bin/sh
#
# Formake optool
#
# Copyright (c) 2015-2017, Oleksiy Chernyavskyy
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

################################################################################
# JUMP TO MODERN SHELL IF POSSIBLE
(test_exit_code_127_sdfjsdfksjdhfksjdhf  >/dev/null) 2>/dev/null
if test $? -ne 127; then
  if test -z "$FORMAKE_BASH_REDIRECT"; then
    FORMAKE_BASH_REDIRECTED=1
    export FORMAKE_BASH_REDIRECTED
    if test -x /bin/bash; then
      exec /bin/bash "$0" ${1+"$@"}
    elif test -x /usr/bin/bash; then
      exec /usr/bin/bash "$0" ${1+"$@"}
    elif test -x /usr/local/bin/bash; then
      exec /usr/local/bin/bash "$0" ${1+"$@"}
    elif test -x /usr/pkg/bin/bash; then
      exec /usr/pkg/bin/bash "$0" ${1+"$@"}
    else
      (bash -c "pwd" >/dev/null) 2>/dev/null
      if test $? -eq 0; then
        exec bash "$0" ${1+"$@"}
      fi
    fi
  fi
fi
FORMAKE_BASH_REDIRECTED=
export FORMAKE_BASH_REDIRECTED
################################################################################


script_name=`basename "$0"`
script_dir=`dirname "$0"`

################################################################################
# LOAD CONFIG
if test -f $script_dir/mk.conf; then
  . $script_dir/mk.conf
fi
if test -f $script_dir/optool.conf; then
  . $script_dir/optool.conf
fi
################################################################################

op_xh=
sbs_param=
disable_special=
param_skip=
op_prefix=
no_case_change=
case x$1 in
  x-h|x-help|x--help)
    cat <<EOF
Command-line options processing tool

$script_name dump [-p PREFIX] [-n] [-] OPTIONS
$script_name hdump [-p PREFIX] [-n] [-] OPTIONS
$script_name validate [xh] VALID_OPTIONS - OPTIONS
$script_name test [!] [any] COND_OPTIONS - OPTIONS
$script_name source OPTIONS

Modes:
  dump       convert all options to SHELL variables: VARIABLE="VALUE"
  hdump      convert all options to CPP defines: #define MACRO "VALUE"
  validate   check options with a list of valid options
  test       test if options have all or any of specified conditional options
  source     generate SHELL script file and print it's path to stdout

dump and hdump options:
  -p PREFIX  add prefix to every variable name: <PREFIX>VARIABLE="VALUE"
  -n         do not convert options to upper case
  -          end of internal options [optional]

validate options:
  xh             ignore the number of leading hyphens in options
  VALID_OPTIONS  list of valid options
  -              delimiter between valid options and input options

test options:
  !             reverse result status
  any           return True if any conditional option is found
  COND_OPTIONS  list of conditional options to check for
  -             delimiter between conditional options and input options
EOF
    exit 0
    ;;
  xdump|xhdump)
    mode=$1
    shift
    while test $# -gt 0; do
      case "$1" in
        -*|*=*)
          if test -n "$sbs_param"; then
            if test $mode = dump; then
              if test -n "$sbs_param_val$sbs_param_set"; then
                echo "$sbs_param=\"$sbs_param_val\""
              else
                echo "FLAG_$sbs_param=1"
              fi
            else
              if test -n "$sbs_param_val$sbs_param_set"; then
                echo "#define $sbs_param \"$sbs_param_val\""
              else
                echo "#define FLAG_$sbs_param 1"
              fi
            fi
            sbs_param=
          fi
          param_skip=
          if test -z "$disable_special"; then
            case "$1" in
              -p)
                shift
                if test -z "$1"; then 
                  echo "$script_name: error: Parameter -p requires argument" >&2
                  exit 1
                fi
                op_prefix=`echo "$1" | sed 's/[^a-zA-Z0-9_]//g'`
                if test -z "$op_prefix"; then 
                  echo "$script_name: error: invalid prefix '$1'" >&2
                  exit 1
                fi
                param_skip=1
                ;;
              -n)
                no_case_change=1
                param_skip=1
                ;;
            esac
          fi
          if test -z "$param_skip"; then
            case "$1" in
              -)
                disable_special=1
                ;;
              *)
                sbs_param=`echo "$1" | sed "s/^-*//" | sed 's/=.*//' | tr '-' '_' | sed 's/[^a-zA-Z0-9_]//g'`
                sbs_param="$op_prefix$sbs_param"
                if test -z $no_case_change; then
                  sbs_param=`echo "$sbs_param" | tr '[a-z]' '[A-Z]'`
                fi
                sbs_param_val=
                sbs_param_set=
                case "$1" in
                  *=*)
                    sbs_param_val=`echo "$1" | sed 's/^[^=]*=//'`
                    sbs_param_set=1
                    ;;
                esac
                ;;
            esac
          fi
          ;;
        *)
          if test -z "$sbs_param" || test x$sbs_param_set = x1; then
            echo "invalid parameter: $1" >&2
            exit 1
          fi
          if test -n "$sbs_param_val"; then
            sbs_param_val="$sbs_param_val $1"
          else
            sbs_param_val="$1"
          fi
          ;;
      esac
      shift
    done
    if test -n "$sbs_param"; then
      if test $mode = dump; then
        if test -n "$sbs_param_val$sbs_param_set"; then
          echo "$sbs_param=\"$sbs_param_val\""
        else
          echo "FLAG_$sbs_param=1"
        fi
      else
        if test -n "$sbs_param_val$sbs_param_set"; then
          echo "#define $sbs_param \"$sbs_param_val\""
        else
          echo "#define FLAG_$sbs_param 1"
        fi
      fi
    fi
    exit 0
    ;;
  xvalidate)
    shift
    if test x"$1" = xxh; then
      shift
      op_xh=1
    fi
    op_delim=
    while test $# -gt 0; do
      param=$1
      if test x$op_xh = x1; then
        param=`echo "$param" | sed 's/^--*/-/'`
      fi
      if test -z "$op_delim"; then
        case "$param" in
          -)
            op_delim=1
            ;;
          *)
            sbs_param=`echo "$param" | sed 's/=.*//' | tr '-' '_' | sed 's/[^a-zA-Z0-9_]//g' | tr '[a-z]' '[A-Z]'`
            eval SBS_VALID_$sbs_param=1
            ;;
        esac
      else
        case "$param" in
          -*|*=*)
            sbs_param=`echo "$param" | sed 's/=.*//' | tr '-' '_' | sed 's/[^a-zA-Z0-9_]//g' | tr '[a-z]' '[A-Z]'`
            eval is_valid=\$SBS_VALID_$sbs_param
            if test x$is_valid != x1; then
              echo "invalid parameter: $param" >&2
              exit 1
            fi
            ;;
          *)
            if test -z "$sbs_param"; then
              echo "invalid parameter: $param" >&2
              exit 1
            fi
            ;;
        esac
      fi
      shift
    done
    exit 0
    ;;
  xtest)
    shift
    if test x"$1" = "x!"; then
      ret_false=0
      ret_true=1
      shift
    else
      ret_false=1
      ret_true=0
    fi
    if test x"$1" = xany; then
      mode=any
      shift
    else
      mode=all
    fi
    op_delim=
    if_ops=
    while test $# -gt 0; do
      if test -z "$op_delim"; then
        case "$1" in
          -)
            op_delim=1
            ;;
          *)
            if_ops="$if_ops $1"
            ;;
        esac
      else
        sbs_param=`echo "$1" | sed 's/=.*//' | tr '-' '_' | sed 's/[^a-zA-Z0-9_]//g' | tr '[a-z]' '[A-Z]'`
        eval SBS_SET_$sbs_param=1
      fi
      shift
    done

    test -z "$if_ops" && exit 0

    for ifop in $if_ops; do
      sbs_param=`echo "$ifop" | sed 's/=.*//' | tr '-' '_' | sed 's/[^a-zA-Z0-9_]//g' | tr '[a-z]' '[A-Z]'`
      eval is_set=\$SBS_SET_$sbs_param
      if test $mode = all; then
        test x$is_set = x1 || exit $ret_false
      else
        test x$is_set = x1 && exit $ret_true
      fi
    done

    if test $mode = all; then
      exit $ret_ture
    else
      exit $ret_false
    fi
    ;;
  xsource)
    shift
    tmp_file=/tmp/op_source$$.sh
    echo "#!/bin/sh" >$tmp_file
    $0 dump "$@" >>$tmp_file
    echo "rm -f $tmp_file" >>$tmp_file
    echo -n "$tmp_file"
    ;;
  x)
    echo "$script_name: error: function not specified" >&2; exit 1
    ;;
  x*)
    echo "$script_name: error: invalid function: $1" >&2; exit 1
    ;;
esac

