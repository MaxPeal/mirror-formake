Overview
-
Formake is a universal toolkit targeted primarily on constructing software configuration and build automation solutions. Formake tools also can be useful for application in other fields, like system administration, for example.

Formake provides a set of portable Shell scripts and detailed directions on developing portable and flexible software build system. Formake explores classic and standard Shell and Make as the base technologies. Since Make "language" is very weak, Formake uses Makefile-generation approach. Formake-based software build system consists of a toplevel **configure** script and a set of **mkmf** scripts that generate Makefiles. Developing software build system involves the following basic steps:

* generating *configure* script using Formake **formake configure** command. This tool has many parameters that allow to customize the output script. The generated *configure* script is workable out of box and at the same time is simple and clear for the following editing to customize even more
* customizing *configure* script if needed
* generating *mkmf* scripts using **formake mkmf** command. *mkmf* scripts are used to generate Makefiles. **formake mkmf** has many parameters to customize the output script. The generated *mkmf* script is workable out of box and at the same time is simple and clear for the following fine tuning
* customizing *mkmf* scripts if needed

Formake philosophy is that all details of a software build process must be under full controll of developer **when it is needed**. In order to make the process of developing fast and easy, Formake provides tools for automatic generation of *configure* and *mkmf* scripts for the following manual tuning for the needs of custom configuration.

A generated scripts are short and clear since much automation code is already written and put in external scripts that Formake provides. Formake is a library of Shell scripts used in *configure* and *mkmf* scripts. Developing software build system is very similar to developing a generic software that uses external libraries.

Quick examples
-
Creating and testing build system for Hello Word program:
~~~bash
cd hello_program

formake install -std cstem
formake configure -name HelloWorld -cc
formake mkmf -srcroot ./ -src hello.c -type prog -name hello

ls -F
> configure*  formake/  hello.c  mkmf*

./configure --prefix=/tmp/test_hello
make
make install
/tmp/test_hello/bin/hello
make uninstall

make dist
ls -F
> build.conf  configure*  configure.log  formake/  hello.c  HelloWorld.tar.gz  Makefile  mkmf*

make distclean
ls -F
> configure*  formake/  hello.c  mkmf*
~~~

**formake install** installs Formake scripts in *./formake* directory.
**formake configure** generates *configure* script.
**formake mkmf** generates *mkmf* script.


Creating and testing a build system for 2 programs that depend on zlib and X11 libraries, with sources in separate subdirectory:
~~~bash
cd test2

formake install -std cstem
formake configure -name test2 -cc -syscap "-lz -lX11 zlib.h X11/Xlib.h"
formake mkmf -srcroot ./ -subdirs src
cd src
formake mkmf -srcroot ../ -foo-src foo.c -foo-type prog -foo-ldflags="-lz" -bar-src bar.c -bar-type prog -bar-ldflags="-lX11"

ls -F
> bar.c  foo.c  mkmf*

cd ..
ls -F
> configure*  formake/  mkmf*  src/

./configure --prefix=/tmp/test2
make
make install
/tmp/test2/bin/foo
/tmp/test2/bin/bar
make uninstall

make dist
ls -F
> build.conf  configure*  configure.log  formake/  test2.tar.gz  Makefile  mkmf*  src/

make distclean
ls -F
> configure*  formake/  mkmf*  src/
~~~
In the above example *configure* checks the existance of package dependencies zlib and X11.

The generated scripts work out of box and does not require additional editing. But when some changes are done, for example added new source files, it will require editing some *mkmf* scripts that are located in directories where changes take place. If, for example, some additional dependencies or build parameters are added than it will require editing *configure* script. Scripts generated by **formake configure** and **formake mkmf** are well formatted, short and commented. With the basic knowledge of Shell editing should be easy.


Background
-

Formake declares the following key principles for **portable** software configuration and build automation solutions:

* build system must be based on standard Shell and Make
* distributable scripts must be portable, with no dependencies except standard Shell
* simple things must be implemented simply
* complex things must be as hard as ordinary programming in Shell
* generated scripts must be nice and clear
* it must be modular
* it must be easily extensible
* stick to traditional UNIX experience, like *./configure; make; make install*

The above principles are put in the design of Formake.
Formake explores standard-based classic tools Shell and Make.

The classic design of UNIX software build system is composed of the following key components:

* **configure** script in the root of a source tree
* **Makefiles** in subdirectories

The following is a standard sequence of commands when building a software:
~~~bash
./configure
make
~~~

Formake uses similar classic model for constructing a software build system. But it extends this model in places where it has conceptual and technological limitations:

* writing portable and correct *configure* script is tedious and error-prone task, if possible at all. Formake resolves this problem by providing 2 technical solutions:
    - Formake provides a set of tools that automate many tasks that are common for *configure* script. It   allows keep *configure* script small and simple because much code is already written and put in external tools. These scripts are simple to use and have many parameters. They can be called from *configure* script at any place and many times with different parameters
    - Formake provides **formake configure** command that generates a well-formatted *configure* script that is workable out of box. A generated *configure* script is split on logical blocks, with descriptive comments and examples. This script is good without any modifications for simple configurations. And it serves as a starting base for complex configurations.
* Makefiles are almost static and require much coding. The fact that Make is not a full-fledged programming language leads to hard limitations. It is very hard to write a correct and full Makefile by hand, it is very error-prone. Makefiles contain many duplicated code. The parametrisation facilities of Makefiles is very weak. Formake resolves this problem using the following approach:
    - Formake declares that Make is good only as a backend technology for implementing target-prerequisite dependencies tracking and Makefiles should not be written manually at all. Formake solution is to generate Makefile from a Shell script. The recommended name of such script is **mkmf**. In every directory where Makefile is needed there must be created a **mkmf** script that generates a corresponding Makefile. The whole Makefile can be put inside *here document* code block in **mkmf**. All parametrised parts of Makefile can be substituted with Shell variables and the whole configuration is written outside *here document* using normal Shell programming language. Going further, all repeatable Makefile blocks can be generated inside *for* or *while* loops. Generally there are absolutely no limitations in parametrisation facilities. Formake offers to put inside **mkmf** a small code block that reads a top-level configuration file generated by *configure*. This is most convenient and sufficient solution to parameterize every **mkmf** script from one place.
    - Formake provides a set of tools that automate many tasks that are common for *mkmf* scripts. Most notable tool is **mkrule** that generates many types of Makefile code blocks. It has many parameters and also it automatically probes build/target system parametes to generate correct system specific code. Using Formake tools allows to keep *mkmf* scripts small and simple. In common cases *mkmf* script contains no Make code at all, everything is generated from *mkrule*.
    - Formake provides **formake mkmf** command for generating a well-formatted *mkmf* scripts that are workable out of box. It works the same as *formake configure* for generating *configure* script. A generated *mkmf* script is split on logical blocks, with descriptive comments and examples. This script is good without any modifications for simple configurations. And it serves as a starting base for complex configurations.

To summarise, constructing software build system using Formake involes the following basic steps:

* generate *configure* script using **formake configure**
* edit *configure* script for custom configuration that can't be achieved using **formake configure** parameters
* generate *mkmf* scripts using **formake mkmf**
* edit *mkmf* scripts for custom configurations that can't be achieved using **formake mkmf** parameters
* use Formake tools in scripts

It must be emphasized that *configure* and *mkmf* scripts are generated only once and are intended for further manual tuning.


The problems of build automation software
-
Different build automation software provide automatic generation of *configure* script and *Makefiles* from input configuration files.

When it comes to using existing build systems from user point of view it works good in many cases. User just runs 'configure; make; make install'. But things are not so simple for a developer. It is a common belief that build system can't be simple by nature. Mostly it is explained by existence of the endless number of possible software configurations, build and target system configurations, compilers, tools, architectures. It is true in cases when complexity is connected with mentioned factors. But it can't be accepted when the source of complexity lies in shortcomings of the underlying design of build automation software, when the scope of possible configurations is limited by capabilities of the underlying description format provided by build automation system. For example, the common case is when it is required to generate parameterized Makefile but the underlying format allows a limited capabilities to make conditional operations, like simple if-than-else. It forces developer to configure his src/module/submodule/Makefile in toplevel 'configure' script, that hardly can be accepted as a right way.

Another factor of complexity is connected with a common problem known as overengineering. A build automation system takes a mission to automate everything and this leads to inventing a freaky language. The objective reality is such that not all tasks can be automated easily. It's not a right way to invent a new language or format instead of using existing Shell that is well-known, standard, portable and just every developer should know it.

A software build system must be treated as a generic program that must be written with a full-fledged programming language, in the same way as a program that is built by that build system. This is a key principle of Formake.

There is only one language that is most convenient for writing software build systems. It is Bash, the variant of Shell. This selection is based on the following factors:

* it exists on every UNIX-based system
* it is standard
* it is simple
* it is convenient for tasks of software configuration and build automation

It explains the reason why Formake is written completely with Shell and a Formake-based software build system is comprised of scripts written solely with Shell.

The following is a list of common problems that raise from the weaknesses of different build automation systems and how they are resolved in Formake way:

* impossibility or a hard way to describe different build configurations for different input parameters
Input parameters can be parameters passed by user, build system or target system parameters. A certain build automation system can provide a static declarative format that is not a programming language at all. Static format limits the scope of possible configurations by the number of configuration variables provided by a format. This approach is known as *Declarative* programming. It has one notable advantage - simplicity. But another side of the simplicity is a limited list os possible configurations. For example, you can't select proper compiler flags based on compiler type and target architecture.
Formake doesn't have such limitations since it uses a full-fledged programming language for writing configuration script. This approach is known as *Imperative* programming, as opposed to declarative approach. Yet Formake implements also declarative model on top of imperative. So it has all the advantages of declarative formats. It is achieved by using **formake configure** and **formake mkmf** commands. These scripts generate configure and mkmf scripts based on a wide range of input parameters that are same as static format variables.
* ....


Formake scripts
-
Formake provides the following set of scripts:

    * abspath         Calculate absolute path
    * cfront          C/C++ compiler frontend
    * cstem           Configure and probe C compiler
    * cstem+          Configure and probe C++ compiler
    * ldlshell        Load interactive shell with predefined LD library path environment
    * ldlwrap         Create program wrapper script with predefined LD library path
    * libro           Build static and dynamic libraries
    * mkdep           Generate dependencies of C/C++ source files for Makefile
    * mkrule          Generate Make rules
    * optool          Command-line options processing tool
    * relpath         Calculate relative path between two directories
    * src2obj         Convert source list to object list
    * syscap          System capabilities query and test tool

    * formake configure     Generate configure script
    * formake install       Install Formake scripts into package
    * formake mkmf          Generate mkmf script
    * formake package       Create build automation package


Basically formake just provides a number of scripts that can be used separately in any tasks that they happen to be useful. Major scripts provide automation of the following tasks:

* find compiler, probe it's parameters, probe target system configuration (cstem, cstem+)
* test built programs locally before installation (ldlshell, ldlwrap)
* build static and dynamic libraries on different systems (libro)
* generate source dependencies for constructing correct Makefiles (mkdep)
* generate simple and complex Make rules (mkrule)
* parse command-line options (optool)
* probe system parameters, probe any dependencies (syscap)
* generate configure script (formake configure)
* generate Makefile generation script (formake mkmf)

Besides the scripts Formake offers a general architecture of a conventional software build system. It is very simple and consist of only 2 key components:

* **configure**. It is a well-known Shell script that performs common system probe and build configuration. Developer can generate parameterized **configure** script using **formake configure**. Generated script works out of the box and it is also easily readable for the following editing. Generated script is split on logical sections with comments and examples. Formake provides a set of tools that do the automation tasks that are common for **configure** scripts. As far as many automation code is already implemented and placed in separate scripts, the **configure** script remains short and easily editable. All that is needed is to know Shell.
* **mkmf**. In every directory that must have a Makefile developer places **mkmf** script that generate a final Makefile. The main idea behind this approach is that Make is not a full-fledged programming language. Some Make versions, like GNU Make, implement different extensions to the standard Make language that allow to do some simple operations. Yet such Make extensions give a little and look perverted and obscure. In addition you bind to a specific Make implementation. The recommended solution is rather evident - use Shell script to generate Makefile. And the recommended name of such script is **mkmf**.  Formake provides a command **formake mkmf** that generates parameterized **mkmf** scripts. Such script can work out of box. It is expected that developer will edit it when he needs more than **formake mkmf** can give. Formake provides tools that automate tasks that are common in **mkmf** scripts. The generated **mkmf** script is well formatted with predefined structure splitted on sections with comments and examples. All that is needed is to know Shell and sometimes Make.

When **configure** is run, at the end it runs the root **mkmf** script that runs other **mkmf** scripts in subdirectories in order. Every **mkmf** script runs **mkmf** in every subdirectory that contains such script.

Formake provides tools and 'architecture'. The 'architecture' provided is not something specific, for many developers it would be rather ordinary and evident. And the evidence is a qualification of simplicity, that comes to be an advantage.

There is one important feature of the above architecture. A distributable software package contains general package-wide **configure** script that performs probe and configuration common for the whole package build. At the same time every subdirectory contains it's own **mkmf** script that performs only configuration specific for only that subdirectory. It looks rather evident here. But there exist some build automation systems that do not allow parameterized configuring of subdirectories in that subdirectories. The only solution they give is to write configuration of all subdirectories in single root **configure** script (or whatever it can be named). It looks rather odd.

It must be noted that Formake only provides tools and recommended approach of developing the final build system. It's up to developer to use recommended way or go with his own. Developer can decide to write **configure** and **mkmf** scripts manually from start to end without using Formake generation tools. Or developer can edit Formake scripts or write his own implementations. Or use any of the Formake scripts in different build automation system. Any of these decisions are correct.

As it was already mentioned Formake scripts can be used in any solutions and configurations where they can be useful. There is no special binding to a job of software build automation. Every script can be used on its own. But a few scripts have dependencies on other scripts. Yet the dependency graph is very short.

This is a simple description of the Formake. Yet there is much more interesting in details.


Key principles in detail
-

